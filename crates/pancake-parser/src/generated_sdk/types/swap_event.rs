//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use solana_pubkey::Pubkey;

/// Emitted by when a swap is performed for a pool
#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SwapEvent {
    /// The pool for which token_0 and token_1 were swapped
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub pool_state: Pubkey,
    /// The address that initiated the swap call, and that received the callback
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub sender: Pubkey,
    /// The payer token account in zero for one swaps, or the recipient token account
    /// in one for zero swaps
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub token_account0: Pubkey,
    /// The payer token account in one for zero swaps, or the recipient token account
    /// in zero for one swaps
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub token_account1: Pubkey,
    /// The real delta amount of the token_0 of the pool or user
    pub amount0: u64,
    /// The transfer fee charged by the withheld_amount of the token_0
    pub transfer_fee0: u64,
    /// The real delta of the token_1 of the pool or user
    pub amount1: u64,
    /// The transfer fee charged by the withheld_amount of the token_1
    pub transfer_fee1: u64,
    /// if true, amount_0 is negtive and amount_1 is positive
    pub zero_for_one: bool,
    /// The sqrt(price) of the pool after the swap, as a Q64.64
    pub sqrt_price_x64: u128,
    /// The liquidity of the pool after the swap
    pub liquidity: u128,
    /// The log base 1.0001 of price of the pool after the swap
    pub tick: i32,
}

impl SwapEvent {
    /// SwapEvent discriminator bytes
    pub const DISCRIMINATOR: [u8; 8] = [0x40, 0xc6, 0xcd, 0xe8, 0x26, 0x08, 0x71, 0xe2];

    /// Parse SwapEvent from program logs
    pub fn from_logs(logs: &[String]) -> Option<Self> {
        for log in logs {
            if let Some(swap_event) = Self::from_log(log) {
                return Some(swap_event);
            }
        }
        None
    }

    /// Parse SwapEvent from a single log message
    pub fn from_log(log: &str) -> Option<Self> {
        use base64::{engine::general_purpose, Engine as _};

        // Log format: "Program data: <base64_encoded_data>"
        if let Some(data_part) = log.strip_prefix("Program data: ") {
            if let Ok(decoded) = general_purpose::STANDARD.decode(data_part) {
                // Check if the decoded data starts with SwapEvent discriminator
                if decoded.starts_with(&Self::DISCRIMINATOR) {
                    // Skip the discriminator (8 bytes) and deserialize the SwapEvent
                    return Self::try_from_slice(&decoded[8..]).ok();
                }
            }
        }
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_discriminator_constant() {
        assert_eq!(
            SwapEvent::DISCRIMINATOR,
            [0x40, 0xc6, 0xcd, 0xe8, 0x26, 0x08, 0x71, 0xe2]
        );
    }

    #[test]
    fn test_parse_real_log_data() {
        // Real program log data from a pancake swap transaction
        let log = "Program data: QMbN6CYIceLJKOGP8tdaLrxgiZ2Oz7GZo2VT6y7JigoCGadWygZ22PplmSDMN3IQuVNoFIbCmHSsX8Z2cNjrywdz+IVKVXVRh+I1FS7aoBy2PxopoBODWxpC8TBo6fr17N31bZDeTbtKlN011KxHQgTd2fmioiHavfVTkaOeKy7UvwP3mX+S4oAOhQAAAAAAAAAAAAAAAACfugYAAAAAAAAAAAAAAAAAAdt2HcVWu505AAAAAAAAAABX92gRywAAAAAAAAAAAAAAe4v//w==";

        let result = SwapEvent::from_log(log);
        assert!(result.is_some(), "Should successfully parse real log data");

        let swap_event = result.unwrap();
        println!("Parsed SwapEvent: {:?}", swap_event);

        // Verify some fields
        assert_eq!(swap_event.amount0, 8720000);
        assert_eq!(swap_event.amount1, 440991);
        assert_eq!(swap_event.transfer_fee0, 0);
        assert_eq!(swap_event.zero_for_one, true);
    }

    #[test]
    fn test_invalid_log_format() {
        let invalid_log = "Invalid log format";
        let result = SwapEvent::from_log(invalid_log);
        assert!(result.is_none(), "Should not parse invalid log format");
    }

    #[test]
    fn test_invalid_discriminator() {
        let log_with_invalid_discriminator =
            "Program data: AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8=";
        let result = SwapEvent::from_log(log_with_invalid_discriminator);
        assert!(
            result.is_none(),
            "Should not parse with invalid discriminator"
        );
    }
}
