//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

#[cfg(feature = "shared-data")]
use std::sync::Arc;

#[cfg(feature = "shared-data")]
use yellowstone_vixen_core::InstructionUpdateOutput;

use crate::{
    deserialize_checked,
    generated::types::AggregationEvent,
    instructions::{
        Claim as ClaimIxAccounts, CommissionSolProxySwap as CommissionSolProxySwapIxAccounts,
        CommissionSolProxySwapInstructionArgs as CommissionSolProxySwapIxData,
        CommissionSolSwap as CommissionSolSwapIxAccounts,
        CommissionSolSwapInstructionArgs as CommissionSolSwapIxData,
        CommissionSplProxySwap as CommissionSplProxySwapIxAccounts,
        CommissionSplProxySwapInstructionArgs as CommissionSplProxySwapIxData,
        CommissionSplSwap as CommissionSplSwapIxAccounts,
        CommissionSplSwapInstructionArgs as CommissionSplSwapIxData,
        CommissionWrapUnwrap as CommissionWrapUnwrapIxAccounts,
        CommissionWrapUnwrapInstructionArgs as CommissionWrapUnwrapIxData,
        CreateTokenAccount as CreateTokenAccountIxAccounts,
        CreateTokenAccountInstructionArgs as CreateTokenAccountIxData,
        CreateTokenAccountWithSeed as CreateTokenAccountWithSeedIxAccounts,
        CreateTokenAccountWithSeedInstructionArgs as CreateTokenAccountWithSeedIxData,
        PlatformFeeSolProxySwapV2 as PlatformFeeSolProxySwapV2IxAccounts,
        PlatformFeeSolProxySwapV2InstructionArgs as PlatformFeeSolProxySwapV2IxData,
        PlatformFeeSolWrapUnwrapV2 as PlatformFeeSolWrapUnwrapV2IxAccounts,
        PlatformFeeSolWrapUnwrapV2InstructionArgs as PlatformFeeSolWrapUnwrapV2IxData,
        PlatformFeeSplProxySwapV2 as PlatformFeeSplProxySwapV2IxAccounts,
        PlatformFeeSplProxySwapV2InstructionArgs as PlatformFeeSplProxySwapV2IxData,
        ProxySwap as ProxySwapIxAccounts, ProxySwapInstructionArgs as ProxySwapIxData,
        Swap as SwapIxAccounts, SwapInstructionArgs as SwapIxData,
        SwapTobV3 as SwapTobV3IxAccounts, SwapTobV3InstructionArgs as SwapTobV3IxData,
        SwapTobV3WithReceiver as SwapTobV3WithReceiverIxAccounts,
        SwapTobV3WithReceiverInstructionArgs as SwapTobV3WithReceiverIxData,
        SwapV3 as SwapV3IxAccounts, SwapV3InstructionArgs as SwapV3IxData,
        WrapUnwrapV3 as WrapUnwrapV3IxAccounts, WrapUnwrapV3InstructionArgs as WrapUnwrapV3IxData,
    },
    ID,
};

/// DexSolana Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum DexSolanaProgramIx {
    Claim(ClaimIxAccounts),
    CommissionSolProxySwap(
        CommissionSolProxySwapIxAccounts,
        CommissionSolProxySwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionSolSwap(
        CommissionSolSwapIxAccounts,
        CommissionSolSwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionSplProxySwap(
        CommissionSplProxySwapIxAccounts,
        CommissionSplProxySwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionSplSwap(
        CommissionSplSwapIxAccounts,
        CommissionSplSwapIxData,
        Option<AggregationEvent>,
    ),
    CommissionWrapUnwrap(CommissionWrapUnwrapIxAccounts, CommissionWrapUnwrapIxData),
    CreateTokenAccount(CreateTokenAccountIxAccounts, CreateTokenAccountIxData),
    CreateTokenAccountWithSeed(
        CreateTokenAccountWithSeedIxAccounts,
        CreateTokenAccountWithSeedIxData,
    ),
    PlatformFeeSolProxySwapV2(
        PlatformFeeSolProxySwapV2IxAccounts,
        PlatformFeeSolProxySwapV2IxData,
        Option<AggregationEvent>,
    ),
    PlatformFeeSolWrapUnwrapV2(
        PlatformFeeSolWrapUnwrapV2IxAccounts,
        PlatformFeeSolWrapUnwrapV2IxData,
    ),
    PlatformFeeSplProxySwapV2(
        PlatformFeeSplProxySwapV2IxAccounts,
        PlatformFeeSplProxySwapV2IxData,
        Option<AggregationEvent>,
    ),
    ProxySwap(
        ProxySwapIxAccounts,
        ProxySwapIxData,
        Option<AggregationEvent>,
    ),
    Swap(SwapIxAccounts, SwapIxData, Option<AggregationEvent>),
    SwapTobV3(
        SwapTobV3IxAccounts,
        SwapTobV3IxData,
        Option<AggregationEvent>,
    ),
    SwapTobV3WithReceiver(
        SwapTobV3WithReceiverIxAccounts,
        SwapTobV3WithReceiverIxData,
        Option<AggregationEvent>,
    ),
    SwapV3(SwapV3IxAccounts, SwapV3IxData, Option<AggregationEvent>),
    WrapUnwrapV3(WrapUnwrapV3IxAccounts, WrapUnwrapV3IxData),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    #[cfg(not(feature = "shared-data"))]
    type Output = DexSolanaProgramIx;
    #[cfg(feature = "shared-data")]
    type Output = InstructionUpdateOutput<DexSolanaProgramIx>;

    fn id(&self) -> std::borrow::Cow<'static, str> {
        std::borrow::Cow::Borrowed("DexSolana::InstructionParser")
    }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            let res = InstructionParser::parse_impl(ix_update);

            #[cfg(feature = "tracing")]
            if let Err(e) = &res {
                let ix_discriminator: [u8; 8] = ix_update.data[0..8].try_into()?;

                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "deserialization_error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            }

            res
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey {
        ID.to_bytes().into()
    }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<<Self as yellowstone_vixen_core::Parser>::Output> {
        let accounts_len = ix.accounts.len();
        let accounts = &mut ix.accounts.iter();

        #[cfg(feature = "shared-data")]
        let shared_data = Arc::clone(&ix.shared);
        #[cfg(feature = "shared-data")]
        let ix_index = ix.ix_index;

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [62, 198, 214, 193, 213, 159, 108, 210] => {
                let expected_accounts_len = 9;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ClaimIxAccounts {
                    signer: next_account(accounts)?,
                    receiver: next_account(accounts)?,
                    source_token_account: next_program_id_optional_account(accounts)?,
                    destination_token_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_account(accounts)?,
                    token_mint: next_program_id_optional_account(accounts)?,
                    token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                };
                Ok(DexSolanaProgramIx::Claim(ix_accounts))
            },
            [30, 33, 208, 91, 31, 157, 37, 18] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSolProxySwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: CommissionSolProxySwapIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSolProxySwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [81, 128, 134, 73, 114, 73, 45, 94] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSolSwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CommissionSolSwapIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSolSwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [96, 67, 12, 151, 129, 164, 18, 71] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSplProxySwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_token_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: CommissionSplProxySwapIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSplProxySwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [235, 71, 211, 196, 114, 199, 143, 92] => {
                let expected_accounts_len = 7;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionSplSwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_token_account: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: CommissionSplSwapIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::CommissionSplSwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [12, 73, 156, 71, 233, 172, 189, 197] => {
                let expected_accounts_len = 8;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CommissionWrapUnwrapIxAccounts {
                    payer: next_account(accounts)?,
                    payer_wsol_account: next_account(accounts)?,
                    wsol_mint: next_account(accounts)?,
                    temp_wsol_account: next_program_id_optional_account(accounts)?,
                    commission_sol_account: next_account(accounts)?,
                    commission_wsol_account: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: CommissionWrapUnwrapIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::CommissionWrapUnwrap(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [147, 241, 123, 100, 244, 132, 174, 118] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenAccountIxAccounts {
                    payer: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    token_account: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateTokenAccountIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::CreateTokenAccount(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [125, 191, 239, 140, 66, 8, 9, 228] => {
                let expected_accounts_len = 6;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = CreateTokenAccountWithSeedIxAccounts {
                    payer: next_account(accounts)?,
                    owner: next_account(accounts)?,
                    token_account: next_account(accounts)?,
                    token_mint: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: CreateTokenAccountWithSeedIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::CreateTokenAccountWithSeed(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [69, 200, 254, 247, 40, 52, 118, 202] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlatformFeeSolProxySwapV2IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: PlatformFeeSolProxySwapV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::PlatformFeeSolProxySwapV2(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [196, 172, 152, 92, 60, 186, 64, 227] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlatformFeeSolWrapUnwrapV2IxAccounts {
                    payer: next_account(accounts)?,
                    payer_wsol_account: next_account(accounts)?,
                    wsol_mint: next_account(accounts)?,
                    temp_wsol_account: next_program_id_optional_account(accounts)?,
                    commission_sol_account: next_account(accounts)?,
                    commission_wsol_account: next_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    system_program: next_account(accounts)?,
                    token_program: next_account(accounts)?,
                };
                let de_ix_data: PlatformFeeSolWrapUnwrapV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::PlatformFeeSolWrapUnwrapV2(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [69, 164, 210, 89, 146, 214, 173, 67] => {
                let expected_accounts_len = 13;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = PlatformFeeSplProxySwapV2IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_token_account: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: PlatformFeeSplProxySwapV2IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::PlatformFeeSplProxySwapV2(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [19, 44, 130, 148, 72, 56, 44, 238] => {
                let expected_accounts_len = 12;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = ProxySwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: ProxySwapIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::ProxySwap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [248, 198, 158, 145, 225, 117, 135, 200] => {
                let expected_accounts_len = 5;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                };
                let de_ix_data: SwapIxData = deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::Swap(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [14, 191, 44, 246, 142, 225, 224, 157] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapTobV3IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: SwapTobV3IxData = deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::SwapTobV3(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [63, 114, 246, 131, 51, 2, 247, 29] => {
                let expected_accounts_len = 15;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapTobV3WithReceiverIxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                    sol_receiver: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: SwapTobV3WithReceiverIxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::SwapTobV3WithReceiver(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [240, 224, 38, 33, 176, 31, 241, 175] => {
                let expected_accounts_len = 14;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = SwapV3IxAccounts {
                    payer: next_account(accounts)?,
                    source_token_account: next_account(accounts)?,
                    destination_token_account: next_account(accounts)?,
                    source_mint: next_account(accounts)?,
                    destination_mint: next_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    sa_authority: next_program_id_optional_account(accounts)?,
                    source_token_sa: next_program_id_optional_account(accounts)?,
                    destination_token_sa: next_program_id_optional_account(accounts)?,
                    source_token_program: next_program_id_optional_account(accounts)?,
                    destination_token_program: next_program_id_optional_account(accounts)?,
                    associated_token_program: next_program_id_optional_account(accounts)?,
                    system_program: next_program_id_optional_account(accounts)?,
                };
                let de_ix_data: SwapV3IxData = deserialize_checked(ix_data, &ix_discriminator)?;
                let aggregation_event = AggregationEvent::from_logs(
                    &ix.parsed_logs
                        .iter()
                        .filter_map(|&idx| ix.shared.log_messages.get(idx).map(|s| s.as_str()))
                        .collect::<Vec<_>>(),
                );
                Ok(DexSolanaProgramIx::SwapV3(
                    ix_accounts,
                    de_ix_data,
                    aggregation_event,
                ))
            },
            [180, 178, 191, 54, 70, 8, 13, 224] => {
                let expected_accounts_len = 10;
                check_min_accounts_req(accounts_len, expected_accounts_len)?;
                let ix_accounts = WrapUnwrapV3IxAccounts {
                    payer: next_account(accounts)?,
                    payer_wsol_account: next_account(accounts)?,
                    wsol_mint: next_account(accounts)?,
                    temp_wsol_account: next_program_id_optional_account(accounts)?,
                    commission_account: next_program_id_optional_account(accounts)?,
                    platform_fee_account: next_program_id_optional_account(accounts)?,
                    authority_pda: next_program_id_optional_account(accounts)?,
                    wsol_sa: next_program_id_optional_account(accounts)?,
                    token_program: next_account(accounts)?,
                    system_program: next_account(accounts)?,
                };
                let de_ix_data: WrapUnwrapV3IxData =
                    deserialize_checked(ix_data, &ix_discriminator)?;
                Ok(DexSolanaProgramIx::WrapUnwrapV3(ix_accounts, de_ix_data))
            },
            // self cpi log
            [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d] => {
                Err(yellowstone_vixen_core::ParseError::Filtered)
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        #[cfg(not(feature = "shared-data"))]
        return ix;

        #[cfg(feature = "shared-data")]
        ix.map(|ix| InstructionUpdateOutput {
            parsed_ix: ix,
            shared_data,
            ix_index,
        })
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

fn next_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
) -> Result<solana_pubkey::Pubkey, yellowstone_vixen_core::ParseError> {
    accounts
        .next()
        .ok_or(yellowstone_vixen_core::ParseError::from(
            "No more accounts to parse",
        ))
        .map(|acc| acc.0.into())
}

/// Gets the next optional account using the ommited account strategy (account is not passed at all at the instruction).
/// ### Be careful to use this function when more than one account is optional in the Instruction.
///  Only by order there is no way to which ones of the optional accounts are present.
pub fn next_optional_account<'a, T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>>(
    accounts: &mut T,
    actual_accounts_len: usize,
    expected_accounts_len: &mut usize,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    if actual_accounts_len == *expected_accounts_len + 1 {
        *expected_accounts_len += 1;
        Ok(Some(next_account(accounts)?))
    } else {
        Ok(None)
    }
}

/// Gets the next optional account using the traditional Program ID strategy.
///  (If account key is the program ID, means account is not present)
pub fn next_program_id_optional_account<
    'a,
    T: Iterator<Item = &'a yellowstone_vixen_core::KeyBytes<32>>,
>(
    accounts: &mut T,
) -> Result<Option<solana_pubkey::Pubkey>, yellowstone_vixen_core::ParseError> {
    let account_key = next_account(accounts)?;
    if account_key.eq(&ID) {
        Ok(None)
    } else {
        Ok(Some(account_key))
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{ClaimIxAccounts, DexSolanaProgramIx, InstructionParser};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::ClaimIxAccounts> for ClaimIxAccounts {
        fn into_proto(self) -> proto_def::ClaimIxAccounts {
            proto_def::ClaimIxAccounts {
                signer: self.signer.to_string(),
                receiver: self.receiver.to_string(),
                source_token_account: self.source_token_account.map(|p| p.to_string()),
                destination_token_account: self.destination_token_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.to_string(),
                token_mint: self.token_mint.map(|p| p.to_string()),
                token_program: self.token_program.map(|p| p.to_string()),
                system_program: self.system_program.to_string(),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
            }
        }
    }
    use super::CommissionSolProxySwapIxAccounts;
    impl IntoProto<proto_def::CommissionSolProxySwapIxAccounts> for CommissionSolProxySwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSolProxySwapIxAccounts {
            proto_def::CommissionSolProxySwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::CommissionSolProxySwapIxData;
    impl IntoProto<proto_def::CommissionSolProxySwapIxData> for CommissionSolProxySwapIxData {
        fn into_proto(self) -> proto_def::CommissionSolProxySwapIxData {
            proto_def::CommissionSolProxySwapIxData {
                data: Some(self.data.into_proto()),
                commission_rate: self.commission_rate.into(),
                commission_direction: self.commission_direction,
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionSolSwapIxAccounts;
    impl IntoProto<proto_def::CommissionSolSwapIxAccounts> for CommissionSolSwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSolSwapIxAccounts {
            proto_def::CommissionSolSwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CommissionSolSwapIxData;
    impl IntoProto<proto_def::CommissionSolSwapIxData> for CommissionSolSwapIxData {
        fn into_proto(self) -> proto_def::CommissionSolSwapIxData {
            proto_def::CommissionSolSwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionSplProxySwapIxAccounts;
    impl IntoProto<proto_def::CommissionSplProxySwapIxAccounts> for CommissionSplProxySwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSplProxySwapIxAccounts {
            proto_def::CommissionSplProxySwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_token_account: self.commission_token_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::CommissionSplProxySwapIxData;
    impl IntoProto<proto_def::CommissionSplProxySwapIxData> for CommissionSplProxySwapIxData {
        fn into_proto(self) -> proto_def::CommissionSplProxySwapIxData {
            proto_def::CommissionSplProxySwapIxData {
                data: Some(self.data.into_proto()),
                commission_rate: self.commission_rate.into(),
                commission_direction: self.commission_direction,
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionSplSwapIxAccounts;
    impl IntoProto<proto_def::CommissionSplSwapIxAccounts> for CommissionSplSwapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionSplSwapIxAccounts {
            proto_def::CommissionSplSwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_token_account: self.commission_token_account.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CommissionSplSwapIxData;
    impl IntoProto<proto_def::CommissionSplSwapIxData> for CommissionSplSwapIxData {
        fn into_proto(self) -> proto_def::CommissionSplSwapIxData {
            proto_def::CommissionSplSwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::CommissionWrapUnwrapIxAccounts;
    impl IntoProto<proto_def::CommissionWrapUnwrapIxAccounts> for CommissionWrapUnwrapIxAccounts {
        fn into_proto(self) -> proto_def::CommissionWrapUnwrapIxAccounts {
            proto_def::CommissionWrapUnwrapIxAccounts {
                payer: self.payer.to_string(),
                payer_wsol_account: self.payer_wsol_account.to_string(),
                wsol_mint: self.wsol_mint.to_string(),
                temp_wsol_account: self.temp_wsol_account.map(|p| p.to_string()),
                commission_sol_account: self.commission_sol_account.to_string(),
                commission_wsol_account: self.commission_wsol_account.to_string(),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::CommissionWrapUnwrapIxData;
    impl IntoProto<proto_def::CommissionWrapUnwrapIxData> for CommissionWrapUnwrapIxData {
        fn into_proto(self) -> proto_def::CommissionWrapUnwrapIxData {
            proto_def::CommissionWrapUnwrapIxData {
                amount_in: self.amount_in,
                wrap_direction: self.wrap_direction,
                commission_rate: self.commission_rate.into(),
                commission_direction: self.commission_direction,
                order_id: self.order_id,
            }
        }
    }
    use super::CreateTokenAccountIxAccounts;
    impl IntoProto<proto_def::CreateTokenAccountIxAccounts> for CreateTokenAccountIxAccounts {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxAccounts {
            proto_def::CreateTokenAccountIxAccounts {
                payer: self.payer.to_string(),
                owner: self.owner.to_string(),
                token_account: self.token_account.to_string(),
                token_mint: self.token_mint.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountIxData;
    impl IntoProto<proto_def::CreateTokenAccountIxData> for CreateTokenAccountIxData {
        fn into_proto(self) -> proto_def::CreateTokenAccountIxData {
            proto_def::CreateTokenAccountIxData {
                bump: self.bump.into(),
            }
        }
    }
    use super::CreateTokenAccountWithSeedIxAccounts;
    impl IntoProto<proto_def::CreateTokenAccountWithSeedIxAccounts>
        for CreateTokenAccountWithSeedIxAccounts
    {
        fn into_proto(self) -> proto_def::CreateTokenAccountWithSeedIxAccounts {
            proto_def::CreateTokenAccountWithSeedIxAccounts {
                payer: self.payer.to_string(),
                owner: self.owner.to_string(),
                token_account: self.token_account.to_string(),
                token_mint: self.token_mint.to_string(),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::CreateTokenAccountWithSeedIxData;
    impl IntoProto<proto_def::CreateTokenAccountWithSeedIxData> for CreateTokenAccountWithSeedIxData {
        fn into_proto(self) -> proto_def::CreateTokenAccountWithSeedIxData {
            proto_def::CreateTokenAccountWithSeedIxData {
                bump: self.bump.into(),
                seed: self.seed,
            }
        }
    }
    use super::PlatformFeeSolProxySwapV2IxAccounts;
    impl IntoProto<proto_def::PlatformFeeSolProxySwapV2IxAccounts>
        for PlatformFeeSolProxySwapV2IxAccounts
    {
        fn into_proto(self) -> proto_def::PlatformFeeSolProxySwapV2IxAccounts {
            proto_def::PlatformFeeSolProxySwapV2IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::PlatformFeeSolProxySwapV2IxData;
    impl IntoProto<proto_def::PlatformFeeSolProxySwapV2IxData> for PlatformFeeSolProxySwapV2IxData {
        fn into_proto(self) -> proto_def::PlatformFeeSolProxySwapV2IxData {
            proto_def::PlatformFeeSolProxySwapV2IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate,
                trim_rate: self.trim_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::PlatformFeeSolWrapUnwrapV2IxAccounts;
    impl IntoProto<proto_def::PlatformFeeSolWrapUnwrapV2IxAccounts>
        for PlatformFeeSolWrapUnwrapV2IxAccounts
    {
        fn into_proto(self) -> proto_def::PlatformFeeSolWrapUnwrapV2IxAccounts {
            proto_def::PlatformFeeSolWrapUnwrapV2IxAccounts {
                payer: self.payer.to_string(),
                payer_wsol_account: self.payer_wsol_account.to_string(),
                wsol_mint: self.wsol_mint.to_string(),
                temp_wsol_account: self.temp_wsol_account.map(|p| p.to_string()),
                commission_sol_account: self.commission_sol_account.to_string(),
                commission_wsol_account: self.commission_wsol_account.to_string(),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                system_program: self.system_program.to_string(),
                token_program: self.token_program.to_string(),
            }
        }
    }
    use super::PlatformFeeSolWrapUnwrapV2IxData;
    impl IntoProto<proto_def::PlatformFeeSolWrapUnwrapV2IxData> for PlatformFeeSolWrapUnwrapV2IxData {
        fn into_proto(self) -> proto_def::PlatformFeeSolWrapUnwrapV2IxData {
            proto_def::PlatformFeeSolWrapUnwrapV2IxData {
                amount_in: self.amount_in,
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate,
                order_id: self.order_id,
            }
        }
    }
    use super::PlatformFeeSplProxySwapV2IxAccounts;
    impl IntoProto<proto_def::PlatformFeeSplProxySwapV2IxAccounts>
        for PlatformFeeSplProxySwapV2IxAccounts
    {
        fn into_proto(self) -> proto_def::PlatformFeeSplProxySwapV2IxAccounts {
            proto_def::PlatformFeeSplProxySwapV2IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_token_account: self.commission_token_account.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::PlatformFeeSplProxySwapV2IxData;
    impl IntoProto<proto_def::PlatformFeeSplProxySwapV2IxData> for PlatformFeeSplProxySwapV2IxData {
        fn into_proto(self) -> proto_def::PlatformFeeSplProxySwapV2IxData {
            proto_def::PlatformFeeSplProxySwapV2IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate,
                trim_rate: self.trim_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::ProxySwapIxAccounts;
    impl IntoProto<proto_def::ProxySwapIxAccounts> for ProxySwapIxAccounts {
        fn into_proto(self) -> proto_def::ProxySwapIxAccounts {
            proto_def::ProxySwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::ProxySwapIxData;
    impl IntoProto<proto_def::ProxySwapIxData> for ProxySwapIxData {
        fn into_proto(self) -> proto_def::ProxySwapIxData {
            proto_def::ProxySwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapIxAccounts;
    impl IntoProto<proto_def::SwapIxAccounts> for SwapIxAccounts {
        fn into_proto(self) -> proto_def::SwapIxAccounts {
            proto_def::SwapIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
            }
        }
    }
    use super::SwapIxData;
    impl IntoProto<proto_def::SwapIxData> for SwapIxData {
        fn into_proto(self) -> proto_def::SwapIxData {
            proto_def::SwapIxData {
                data: Some(self.data.into_proto()),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapTobV3IxAccounts;
    impl IntoProto<proto_def::SwapTobV3IxAccounts> for SwapTobV3IxAccounts {
        fn into_proto(self) -> proto_def::SwapTobV3IxAccounts {
            proto_def::SwapTobV3IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::SwapTobV3IxData;
    impl IntoProto<proto_def::SwapTobV3IxData> for SwapTobV3IxData {
        fn into_proto(self) -> proto_def::SwapTobV3IxData {
            proto_def::SwapTobV3IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                trim_rate: self.trim_rate.into(),
                platform_fee_rate: self.platform_fee_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapTobV3WithReceiverIxAccounts;
    impl IntoProto<proto_def::SwapTobV3WithReceiverIxAccounts> for SwapTobV3WithReceiverIxAccounts {
        fn into_proto(self) -> proto_def::SwapTobV3WithReceiverIxAccounts {
            proto_def::SwapTobV3WithReceiverIxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
                sol_receiver: self.sol_receiver.map(|p| p.to_string()),
            }
        }
    }
    use super::SwapTobV3WithReceiverIxData;
    impl IntoProto<proto_def::SwapTobV3WithReceiverIxData> for SwapTobV3WithReceiverIxData {
        fn into_proto(self) -> proto_def::SwapTobV3WithReceiverIxData {
            proto_def::SwapTobV3WithReceiverIxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                trim_rate: self.trim_rate.into(),
                platform_fee_rate: self.platform_fee_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::SwapV3IxAccounts;
    impl IntoProto<proto_def::SwapV3IxAccounts> for SwapV3IxAccounts {
        fn into_proto(self) -> proto_def::SwapV3IxAccounts {
            proto_def::SwapV3IxAccounts {
                payer: self.payer.to_string(),
                source_token_account: self.source_token_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                source_mint: self.source_mint.to_string(),
                destination_mint: self.destination_mint.to_string(),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                sa_authority: self.sa_authority.map(|p| p.to_string()),
                source_token_sa: self.source_token_sa.map(|p| p.to_string()),
                destination_token_sa: self.destination_token_sa.map(|p| p.to_string()),
                source_token_program: self.source_token_program.map(|p| p.to_string()),
                destination_token_program: self.destination_token_program.map(|p| p.to_string()),
                associated_token_program: self.associated_token_program.map(|p| p.to_string()),
                system_program: self.system_program.map(|p| p.to_string()),
            }
        }
    }
    use super::SwapV3IxData;
    impl IntoProto<proto_def::SwapV3IxData> for SwapV3IxData {
        fn into_proto(self) -> proto_def::SwapV3IxData {
            proto_def::SwapV3IxData {
                args: Some(self.args.into_proto()),
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate.into(),
                order_id: self.order_id,
            }
        }
    }
    use super::WrapUnwrapV3IxAccounts;
    impl IntoProto<proto_def::WrapUnwrapV3IxAccounts> for WrapUnwrapV3IxAccounts {
        fn into_proto(self) -> proto_def::WrapUnwrapV3IxAccounts {
            proto_def::WrapUnwrapV3IxAccounts {
                payer: self.payer.to_string(),
                payer_wsol_account: self.payer_wsol_account.to_string(),
                wsol_mint: self.wsol_mint.to_string(),
                temp_wsol_account: self.temp_wsol_account.map(|p| p.to_string()),
                commission_account: self.commission_account.map(|p| p.to_string()),
                platform_fee_account: self.platform_fee_account.map(|p| p.to_string()),
                authority_pda: self.authority_pda.map(|p| p.to_string()),
                wsol_sa: self.wsol_sa.map(|p| p.to_string()),
                token_program: self.token_program.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::WrapUnwrapV3IxData;
    impl IntoProto<proto_def::WrapUnwrapV3IxData> for WrapUnwrapV3IxData {
        fn into_proto(self) -> proto_def::WrapUnwrapV3IxData {
            proto_def::WrapUnwrapV3IxData {
                order_id: self.order_id,
                amount_in: self.amount_in,
                commission_info: self.commission_info,
                platform_fee_rate: self.platform_fee_rate.into(),
                tob: self.tob,
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for DexSolanaProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                DexSolanaProgramIx::Claim(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Claim(proto_def::ClaimIx {
                        accounts: Some(acc.into_proto()),
                    })),
                },
                DexSolanaProgramIx::CommissionSolProxySwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSolProxySwap(
                        proto_def::CommissionSolProxySwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionSolSwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSolSwap(
                        proto_def::CommissionSolSwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionSplProxySwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSplProxySwap(
                        proto_def::CommissionSplProxySwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionSplSwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionSplSwap(
                        proto_def::CommissionSplSwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CommissionWrapUnwrap(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CommissionWrapUnwrap(
                        proto_def::CommissionWrapUnwrapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CreateTokenAccount(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CreateTokenAccount(
                        proto_def::CreateTokenAccountIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::CreateTokenAccountWithSeed(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::CreateTokenAccountWithSeed(
                                proto_def::CreateTokenAccountWithSeedIx {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DexSolanaProgramIx::PlatformFeeSolProxySwapV2(acc, data, _) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::PlatformFeeSolProxySwapV2(
                            proto_def::PlatformFeeSolProxySwapV2Ix {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                DexSolanaProgramIx::PlatformFeeSolWrapUnwrapV2(acc, data) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(
                            proto_def::program_ixs::IxOneof::PlatformFeeSolWrapUnwrapV2(
                                proto_def::PlatformFeeSolWrapUnwrapV2Ix {
                                    accounts: Some(acc.into_proto()),
                                    data: Some(data.into_proto()),
                                },
                            ),
                        ),
                    }
                },
                DexSolanaProgramIx::PlatformFeeSplProxySwapV2(acc, data, _) => {
                    proto_def::ProgramIxs {
                        ix_oneof: Some(proto_def::program_ixs::IxOneof::PlatformFeeSplProxySwapV2(
                            proto_def::PlatformFeeSplProxySwapV2Ix {
                                accounts: Some(acc.into_proto()),
                                data: Some(data.into_proto()),
                            },
                        )),
                    }
                },
                DexSolanaProgramIx::ProxySwap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::ProxySwap(
                        proto_def::ProxySwapIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::Swap(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::Swap(proto_def::SwapIx {
                        accounts: Some(acc.into_proto()),
                        data: Some(data.into_proto()),
                    })),
                },
                DexSolanaProgramIx::SwapTobV3(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapTobV3(
                        proto_def::SwapTobV3Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::SwapTobV3WithReceiver(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapTobV3WithReceiver(
                        proto_def::SwapTobV3WithReceiverIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::SwapV3(acc, data, _) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::SwapV3(
                        proto_def::SwapV3Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                DexSolanaProgramIx::WrapUnwrapV3(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::WrapUnwrapV3(
                        proto_def::WrapUnwrapV3Ix {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message {
            #[cfg(not(feature = "shared-data"))]
            return value.into_proto();

            #[cfg(feature = "shared-data")]
            value.parsed_ix.into_proto()
        }
    }
}
