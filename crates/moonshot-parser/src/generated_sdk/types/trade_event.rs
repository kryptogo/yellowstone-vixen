//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::{BorshDeserialize, BorshSerialize};
use solana_pubkey::Pubkey;

use crate::generated_sdk::types::TradeType;

#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct TradeEvent {
    pub amount: u64,
    pub collateral_amount: u64,
    pub dex_fee: u64,
    pub helio_fee: u64,
    pub allocation: u64,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub curve: Pubkey,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub cost_token: Pubkey,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub sender: Pubkey,
    pub trade_type: TradeType,
    pub label: String,
}

impl TradeEvent {
    /// TradeEvent discriminator bytes
    pub const DISCRIMINATOR: [u8; 8] = [0xbd, 0xdb, 0x7f, 0xd3, 0x4e, 0xe6, 0x61, 0xee];

    /// Parse TradeEvent from program logs
    pub fn from_logs(logs: &[&str]) -> Option<Self> {
        for log in logs {
            if let Some(event) = Self::from_log(log) {
                return Some(event);
            }
        }
        None
    }

    /// Parse TradeEvent from a single log message
    pub fn from_log(log: &str) -> Option<Self> {
        use base64::{engine::general_purpose, Engine as _};

        if let Some(data_part) = log.strip_prefix("Program data: ") {
            if let Ok(decoded) = general_purpose::STANDARD.decode(data_part) {
                if decoded.starts_with(&Self::DISCRIMINATOR) {
                    return Self::try_from_slice(&decoded[8..]).ok();
                }
            }
        }
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_discriminator_constant() {
        assert_eq!(TradeEvent::DISCRIMINATOR, [
            0xbd, 0xdb, 0x7f, 0xd3, 0x4e, 0xe6, 0x61, 0xee
        ]);
    }

    #[test]
    fn test_parse_trade_event_from_log() {
        let log = "Program data: vdt/007mYe7P3j5C9BqmAABnBHYAAAAAgJaYAAAAAACAlpgAAAAAAFwtP2FzlRwDoIA5U/8DsLdd9ZDFRK6zmmzLJi25xjcGGTdigKfOUCkGm4hX/quBhPtof2NGGMA12sQ53BrrO1WYoPAAAAAAAd5pTwtBGedhI4tMx+9Oml+OBfCkr5GRxIpnIy69FVymAAUAAAB0cmFkZQ==";

        let result = TradeEvent::from_log(log);
        assert!(
            result.is_some(),
            "Should successfully parse TradeEvent from log"
        );

        let event = result.unwrap();
        assert_eq!(event.label, "trade", "label should match");
        assert_eq!(event.amount, 46754482519727823);
        assert_eq!(event.collateral_amount, 1980000000);
        println!("Parsed TradeEvent: {event:?}");

        let log = "Program data: vdt/007mYe5+69agxinjABiqV3EAAAAADBSRAAAAAAANFJEAAAAAAJwPyfWwjQAA4kLzMV02E8Dgs/GkWroE9891010Lx+5VXjb/28NKAFQGm4hX/quBhPtof2NGGMA12sQ53BrrO1WYoPAAAAAAARKfzf+PsZPUrYkbeJQ2an32j3NtMKAL6fNoqhIH5jWKAQUAAAB0cmFkZQ==";

        let result = TradeEvent::from_log(log);
        assert!(
            result.is_some(),
            "Should successfully parse TradeEvent from log"
        );

        let event = result.unwrap();
        assert_eq!(event.label, "trade", "label should match");
        assert_eq!(event.amount, 63940752792021886);
        assert_eq!(event.collateral_amount, 1901570584);
        println!("Parsed TradeEvent: {event:?}");
    }

    #[test]
    fn test_invalid_log_format() {
        let invalid_log = "Invalid log format";
        let result = TradeEvent::from_log(invalid_log);
        assert!(result.is_none(), "Should not parse invalid log format");
    }

    #[test]
    fn test_invalid_discriminator() {
        let log_with_invalid_discriminator =
            "Program data: AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8=";
        let result = TradeEvent::from_log(log_with_invalid_discriminator);
        assert!(
            result.is_none(),
            "Should not parse with invalid discriminator"
        );
    }
}
