//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::BorshDeserialize;

use crate::{
    instructions::{
        CancelDustOrder as CancelDustOrderIxAccounts,
        CancelDustOrderInstructionArgs as CancelDustOrderIxData,
        CancelOrder as CancelOrderIxAccounts, FillOrder as FillOrderIxAccounts,
        FillOrderInstructionArgs as FillOrderIxData, FlashFillOrder as FlashFillOrderIxAccounts,
        FlashFillOrderInstructionArgs as FlashFillOrderIxData,
        InitializeOrder as InitializeOrderIxAccounts,
        InitializeOrderInstructionArgs as InitializeOrderIxData,
        PreFlashFillOrder as PreFlashFillOrderIxAccounts,
        PreFlashFillOrderInstructionArgs as PreFlashFillOrderIxData,
        UpdateFee as UpdateFeeIxAccounts, UpdateFeeInstructionArgs as UpdateFeeIxData,
        WithdrawFee as WithdrawFeeIxAccounts,
    },
    ID,
};

/// LimitOrder2 Instructions
#[derive(Debug)]
#[cfg_attr(feature = "tracing", derive(strum_macros::Display))]
pub enum LimitOrder2ProgramIx {
    CancelDustOrder(CancelDustOrderIxAccounts, CancelDustOrderIxData),
    CancelOrder(CancelOrderIxAccounts),
    FillOrder(FillOrderIxAccounts, FillOrderIxData),
    FlashFillOrder(FlashFillOrderIxAccounts, FlashFillOrderIxData),
    InitializeOrder(InitializeOrderIxAccounts, InitializeOrderIxData),
    PreFlashFillOrder(PreFlashFillOrderIxAccounts, PreFlashFillOrderIxData),
    UpdateFee(UpdateFeeIxAccounts, UpdateFeeIxData),
    WithdrawFee(WithdrawFeeIxAccounts),
}

#[derive(Debug, Copy, Clone)]
pub struct InstructionParser;

impl yellowstone_vixen_core::Parser for InstructionParser {
    type Input = yellowstone_vixen_core::instruction::InstructionUpdate;
    type Output = LimitOrder2ProgramIx;

    fn id(&self) -> std::borrow::Cow<'static, str> { "LimitOrder2::InstructionParser".into() }

    fn prefilter(&self) -> yellowstone_vixen_core::Prefilter {
        yellowstone_vixen_core::Prefilter::builder()
            .transaction_accounts([ID])
            .build()
            .unwrap()
    }

    async fn parse(
        &self,
        ix_update: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<Self::Output> {
        if ix_update.program.equals_ref(ID) {
            InstructionParser::parse_impl(ix_update)
        } else {
            Err(yellowstone_vixen_core::ParseError::Filtered)
        }
    }
}

impl yellowstone_vixen_core::ProgramParser for InstructionParser {
    #[inline]
    fn program_id(&self) -> yellowstone_vixen_core::Pubkey { ID.to_bytes().into() }
}

impl InstructionParser {
    pub(crate) fn parse_impl(
        ix: &yellowstone_vixen_core::instruction::InstructionUpdate,
    ) -> yellowstone_vixen_core::ParseResult<LimitOrder2ProgramIx> {
        let accounts_len = ix.accounts.len();

        let ix_discriminator: [u8; 8] = ix.data[0..8].try_into()?;
        let mut ix_data = &ix.data[8..];
        let ix = match ix_discriminator {
            [197, 112, 189, 164, 79, 48, 23, 246] => {
                check_min_accounts_req(accounts_len, 11)?;
                let ix_accounts = CancelDustOrderIxAccounts {
                    signer: ix.accounts[0].0.into(),
                    maker: ix.accounts[1].0.into(),
                    order: ix.accounts[2].0.into(),
                    input_mint_reserve: ix.accounts[3].0.into(),
                    maker_input_mint_account: ix.accounts[4].0.into(),
                    input_mint: ix.accounts[5].0.into(),
                    input_token_program: ix.accounts[6].0.into(),
                    system_program: ix.accounts[7].0.into(),
                    associated_token_program: ix.accounts[8].0.into(),
                    event_authority: ix.accounts[9].0.into(),
                    program: ix.accounts[10].0.into(),
                };
                let de_ix_data: CancelDustOrderIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrder2ProgramIx::CancelDustOrder(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [95, 129, 237, 240, 8, 49, 223, 132] => {
                check_min_accounts_req(accounts_len, 9)?;
                let ix_accounts = CancelOrderIxAccounts {
                    signer: ix.accounts[0].0.into(),
                    maker: ix.accounts[1].0.into(),
                    order: ix.accounts[2].0.into(),
                    input_mint_reserve: ix.accounts[3].0.into(),
                    maker_input_mint_account: if ix.accounts[4]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[4].0.into())
                    },
                    input_mint: ix.accounts[5].0.into(),
                    input_token_program: ix.accounts[6].0.into(),
                    event_authority: ix.accounts[7].0.into(),
                    program: ix.accounts[8].0.into(),
                };
                Ok(LimitOrder2ProgramIx::CancelOrder(ix_accounts))
            },
            [232, 122, 115, 25, 199, 143, 136, 162] => {
                check_min_accounts_req(accounts_len, 16)?;
                let ix_accounts = FillOrderIxAccounts {
                    taker: ix.accounts[0].0.into(),
                    maker: ix.accounts[1].0.into(),
                    order: ix.accounts[2].0.into(),
                    taker_input_mint_account: ix.accounts[3].0.into(),
                    taker_output_mint_account: ix.accounts[4].0.into(),
                    maker_output_mint_account: if ix.accounts[5]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[5].0.into())
                    },
                    fee_account: ix.accounts[6].0.into(),
                    order_input_mint_account: ix.accounts[7].0.into(),
                    input_mint: ix.accounts[8].0.into(),
                    input_token_program: ix.accounts[9].0.into(),
                    output_mint: ix.accounts[10].0.into(),
                    output_token_program: ix.accounts[11].0.into(),
                    jupiter_program: ix.accounts[12].0.into(),
                    system_program: ix.accounts[13].0.into(),
                    event_authority: ix.accounts[14].0.into(),
                    program: ix.accounts[15].0.into(),
                };
                let de_ix_data: FillOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrder2ProgramIx::FillOrder(ix_accounts, de_ix_data))
            },
            [252, 104, 18, 134, 164, 78, 18, 140] => {
                check_min_accounts_req(accounts_len, 13)?;
                let ix_accounts = FlashFillOrderIxAccounts {
                    taker: ix.accounts[0].0.into(),
                    maker: ix.accounts[1].0.into(),
                    order: ix.accounts[2].0.into(),
                    input_mint_reserve: ix.accounts[3].0.into(),
                    maker_output_mint_account: if ix.accounts[4]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[4].0.into())
                    },
                    taker_output_mint_account: if ix.accounts[5]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[5].0.into())
                    },
                    fee_account: ix.accounts[6].0.into(),
                    input_token_program: ix.accounts[7].0.into(),
                    output_mint: ix.accounts[8].0.into(),
                    output_token_program: ix.accounts[9].0.into(),
                    system_program: ix.accounts[10].0.into(),
                    event_authority: ix.accounts[11].0.into(),
                    program: ix.accounts[12].0.into(),
                };
                let de_ix_data: FlashFillOrderIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrder2ProgramIx::FlashFillOrder(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [133, 110, 74, 175, 112, 159, 245, 159] => {
                check_min_accounts_req(accounts_len, 15)?;
                let ix_accounts = InitializeOrderIxAccounts {
                    payer: ix.accounts[0].0.into(),
                    maker: ix.accounts[1].0.into(),
                    order: ix.accounts[2].0.into(),
                    input_mint_reserve: ix.accounts[3].0.into(),
                    maker_input_mint_account: ix.accounts[4].0.into(),
                    fee: ix.accounts[5].0.into(),
                    referral: if ix.accounts[6]
                        .eq(&yellowstone_vixen_core::KeyBytes::from(ID.to_bytes()))
                    {
                        None
                    } else {
                        Some(ix.accounts[6].0.into())
                    },
                    input_mint: ix.accounts[7].0.into(),
                    output_mint: ix.accounts[8].0.into(),
                    input_token_program: ix.accounts[9].0.into(),
                    output_token_program: ix.accounts[10].0.into(),
                    system_program: ix.accounts[11].0.into(),
                    associated_token_program: ix.accounts[12].0.into(),
                    event_authority: ix.accounts[13].0.into(),
                    program: ix.accounts[14].0.into(),
                };
                let de_ix_data: InitializeOrderIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrder2ProgramIx::InitializeOrder(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [240, 47, 153, 68, 13, 190, 225, 42] => {
                check_min_accounts_req(accounts_len, 7)?;
                let ix_accounts = PreFlashFillOrderIxAccounts {
                    taker: ix.accounts[0].0.into(),
                    order: ix.accounts[1].0.into(),
                    input_mint_reserve: ix.accounts[2].0.into(),
                    taker_input_mint_account: ix.accounts[3].0.into(),
                    input_mint: ix.accounts[4].0.into(),
                    input_token_program: ix.accounts[5].0.into(),
                    instruction: ix.accounts[6].0.into(),
                };
                let de_ix_data: PreFlashFillOrderIxData =
                    BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrder2ProgramIx::PreFlashFillOrder(
                    ix_accounts,
                    de_ix_data,
                ))
            },
            [232, 253, 195, 247, 148, 212, 73, 222] => {
                check_min_accounts_req(accounts_len, 3)?;
                let ix_accounts = UpdateFeeIxAccounts {
                    admin: ix.accounts[0].0.into(),
                    fee_authority: ix.accounts[1].0.into(),
                    system_program: ix.accounts[2].0.into(),
                };
                let de_ix_data: UpdateFeeIxData = BorshDeserialize::deserialize(&mut ix_data)?;
                Ok(LimitOrder2ProgramIx::UpdateFee(ix_accounts, de_ix_data))
            },
            [14, 122, 231, 218, 31, 238, 223, 150] => {
                check_min_accounts_req(accounts_len, 6)?;
                let ix_accounts = WithdrawFeeIxAccounts {
                    admin: ix.accounts[0].0.into(),
                    fee_authority: ix.accounts[1].0.into(),
                    program_fee_account: ix.accounts[2].0.into(),
                    destination_token_account: ix.accounts[3].0.into(),
                    token_program: ix.accounts[4].0.into(),
                    mint: ix.accounts[5].0.into(),
                };
                Ok(LimitOrder2ProgramIx::WithdrawFee(ix_accounts))
            },
            _ => Err(yellowstone_vixen_core::ParseError::from(
                "Invalid Instruction discriminator".to_owned(),
            )),
        };

        #[cfg(feature = "tracing")]
        match &ix {
            Ok(ix) => {
                tracing::info!(
                    name: "correctly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = ix.to_string()
                );
            },
            Err(e) => {
                tracing::info!(
                    name: "incorrectly_parsed_instruction",
                    name = "ix_update",
                    program = ID.to_string(),
                    ix = "error",
                    discriminator = ?ix_discriminator,
                    error = ?e
                );
            },
        }

        ix
    }
}

pub fn check_min_accounts_req(
    actual: usize,
    expected: usize,
) -> yellowstone_vixen_core::ParseResult<()> {
    if actual < expected {
        Err(yellowstone_vixen_core::ParseError::from(format!(
            "Too few accounts provided: expected {expected}, got {actual}"
        )))
    } else {
        Ok(())
    }
}

// #[cfg(feature = "proto")]
mod proto_parser {
    use yellowstone_vixen_core::proto::ParseProto;

    use super::{CancelDustOrderIxAccounts, InstructionParser, LimitOrder2ProgramIx};
    use crate::{proto_def, proto_helpers::proto_types_parsers::IntoProto};
    impl IntoProto<proto_def::CancelDustOrderIxAccounts> for CancelDustOrderIxAccounts {
        fn into_proto(self) -> proto_def::CancelDustOrderIxAccounts {
            proto_def::CancelDustOrderIxAccounts {
                signer: self.signer.to_string(),
                maker: self.maker.to_string(),
                order: self.order.to_string(),
                input_mint_reserve: self.input_mint_reserve.to_string(),
                maker_input_mint_account: self.maker_input_mint_account.to_string(),
                input_mint: self.input_mint.to_string(),
                input_token_program: self.input_token_program.to_string(),
                system_program: self.system_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::CancelDustOrderIxData;
    impl IntoProto<proto_def::CancelDustOrderIxData> for CancelDustOrderIxData {
        fn into_proto(self) -> proto_def::CancelDustOrderIxData {
            proto_def::CancelDustOrderIxData {
                one_usd_input_mint_amount: self.one_usd_input_mint_amount,
            }
        }
    }
    use super::CancelOrderIxAccounts;
    impl IntoProto<proto_def::CancelOrderIxAccounts> for CancelOrderIxAccounts {
        fn into_proto(self) -> proto_def::CancelOrderIxAccounts {
            proto_def::CancelOrderIxAccounts {
                signer: self.signer.to_string(),
                maker: self.maker.to_string(),
                order: self.order.to_string(),
                input_mint_reserve: self.input_mint_reserve.to_string(),
                maker_input_mint_account: self.maker_input_mint_account.map(|p| p.to_string()),
                input_mint: self.input_mint.to_string(),
                input_token_program: self.input_token_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::FillOrderIxAccounts;
    impl IntoProto<proto_def::FillOrderIxAccounts> for FillOrderIxAccounts {
        fn into_proto(self) -> proto_def::FillOrderIxAccounts {
            proto_def::FillOrderIxAccounts {
                taker: self.taker.to_string(),
                maker: self.maker.to_string(),
                order: self.order.to_string(),
                taker_input_mint_account: self.taker_input_mint_account.to_string(),
                taker_output_mint_account: self.taker_output_mint_account.to_string(),
                maker_output_mint_account: self.maker_output_mint_account.map(|p| p.to_string()),
                fee_account: self.fee_account.to_string(),
                order_input_mint_account: self.order_input_mint_account.to_string(),
                input_mint: self.input_mint.to_string(),
                input_token_program: self.input_token_program.to_string(),
                output_mint: self.output_mint.to_string(),
                output_token_program: self.output_token_program.to_string(),
                jupiter_program: self.jupiter_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::FillOrderIxData;
    impl IntoProto<proto_def::FillOrderIxData> for FillOrderIxData {
        fn into_proto(self) -> proto_def::FillOrderIxData {
            proto_def::FillOrderIxData {
                input_amount: self.input_amount,
                swap_data: self
                    .swap_data
                    .chunks(4)
                    .map(|chunk| {
                        u32::from_le_bytes([
                            chunk.first().copied().unwrap_or(0),
                            chunk.get(1).copied().unwrap_or(0),
                            chunk.get(2).copied().unwrap_or(0),
                            chunk.get(3).copied().unwrap_or(0),
                        ])
                    })
                    .collect(),
            }
        }
    }
    use super::FlashFillOrderIxAccounts;
    impl IntoProto<proto_def::FlashFillOrderIxAccounts> for FlashFillOrderIxAccounts {
        fn into_proto(self) -> proto_def::FlashFillOrderIxAccounts {
            proto_def::FlashFillOrderIxAccounts {
                taker: self.taker.to_string(),
                maker: self.maker.to_string(),
                order: self.order.to_string(),
                input_mint_reserve: self.input_mint_reserve.to_string(),
                maker_output_mint_account: self.maker_output_mint_account.map(|p| p.to_string()),
                taker_output_mint_account: self.taker_output_mint_account.map(|p| p.to_string()),
                fee_account: self.fee_account.to_string(),
                input_token_program: self.input_token_program.to_string(),
                output_mint: self.output_mint.to_string(),
                output_token_program: self.output_token_program.to_string(),
                system_program: self.system_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::FlashFillOrderIxData;
    impl IntoProto<proto_def::FlashFillOrderIxData> for FlashFillOrderIxData {
        fn into_proto(self) -> proto_def::FlashFillOrderIxData {
            proto_def::FlashFillOrderIxData {
                max_taking_amount: self.max_taking_amount,
            }
        }
    }
    use super::InitializeOrderIxAccounts;
    impl IntoProto<proto_def::InitializeOrderIxAccounts> for InitializeOrderIxAccounts {
        fn into_proto(self) -> proto_def::InitializeOrderIxAccounts {
            proto_def::InitializeOrderIxAccounts {
                payer: self.payer.to_string(),
                maker: self.maker.to_string(),
                order: self.order.to_string(),
                input_mint_reserve: self.input_mint_reserve.to_string(),
                maker_input_mint_account: self.maker_input_mint_account.to_string(),
                fee: self.fee.to_string(),
                referral: self.referral.map(|p| p.to_string()),
                input_mint: self.input_mint.to_string(),
                output_mint: self.output_mint.to_string(),
                input_token_program: self.input_token_program.to_string(),
                output_token_program: self.output_token_program.to_string(),
                system_program: self.system_program.to_string(),
                associated_token_program: self.associated_token_program.to_string(),
                event_authority: self.event_authority.to_string(),
                program: self.program.to_string(),
            }
        }
    }
    use super::InitializeOrderIxData;
    impl IntoProto<proto_def::InitializeOrderIxData> for InitializeOrderIxData {
        fn into_proto(self) -> proto_def::InitializeOrderIxData {
            proto_def::InitializeOrderIxData {
                unique_id: self.unique_id,
                making_amount: self.making_amount,
                taking_amount: self.taking_amount,
                expired_at: self.expired_at,
                fee_bps: self.fee_bps.map(|x| x.into()),
                slippage_bps: self.slippage_bps.map(|x| x.into()),
            }
        }
    }
    use super::PreFlashFillOrderIxAccounts;
    impl IntoProto<proto_def::PreFlashFillOrderIxAccounts> for PreFlashFillOrderIxAccounts {
        fn into_proto(self) -> proto_def::PreFlashFillOrderIxAccounts {
            proto_def::PreFlashFillOrderIxAccounts {
                taker: self.taker.to_string(),
                order: self.order.to_string(),
                input_mint_reserve: self.input_mint_reserve.to_string(),
                taker_input_mint_account: self.taker_input_mint_account.to_string(),
                input_mint: self.input_mint.to_string(),
                input_token_program: self.input_token_program.to_string(),
                instruction: self.instruction.to_string(),
            }
        }
    }
    use super::PreFlashFillOrderIxData;
    impl IntoProto<proto_def::PreFlashFillOrderIxData> for PreFlashFillOrderIxData {
        fn into_proto(self) -> proto_def::PreFlashFillOrderIxData {
            proto_def::PreFlashFillOrderIxData {
                making_amount: self.making_amount,
            }
        }
    }
    use super::UpdateFeeIxAccounts;
    impl IntoProto<proto_def::UpdateFeeIxAccounts> for UpdateFeeIxAccounts {
        fn into_proto(self) -> proto_def::UpdateFeeIxAccounts {
            proto_def::UpdateFeeIxAccounts {
                admin: self.admin.to_string(),
                fee_authority: self.fee_authority.to_string(),
                system_program: self.system_program.to_string(),
            }
        }
    }
    use super::UpdateFeeIxData;
    impl IntoProto<proto_def::UpdateFeeIxData> for UpdateFeeIxData {
        fn into_proto(self) -> proto_def::UpdateFeeIxData {
            proto_def::UpdateFeeIxData {
                normal_fee_bps: self.normal_fee_bps.into(),
                stable_fee_bps: self.stable_fee_bps.into(),
            }
        }
    }
    use super::WithdrawFeeIxAccounts;
    impl IntoProto<proto_def::WithdrawFeeIxAccounts> for WithdrawFeeIxAccounts {
        fn into_proto(self) -> proto_def::WithdrawFeeIxAccounts {
            proto_def::WithdrawFeeIxAccounts {
                admin: self.admin.to_string(),
                fee_authority: self.fee_authority.to_string(),
                program_fee_account: self.program_fee_account.to_string(),
                destination_token_account: self.destination_token_account.to_string(),
                token_program: self.token_program.to_string(),
                mint: self.mint.to_string(),
            }
        }
    }

    impl IntoProto<proto_def::ProgramIxs> for LimitOrder2ProgramIx {
        fn into_proto(self) -> proto_def::ProgramIxs {
            match self {
                LimitOrder2ProgramIx::CancelDustOrder(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CancelDustOrder(
                        proto_def::CancelDustOrderIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                LimitOrder2ProgramIx::CancelOrder(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::CancelOrder(
                        proto_def::CancelOrderIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
                LimitOrder2ProgramIx::FillOrder(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::FillOrder(
                        proto_def::FillOrderIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                LimitOrder2ProgramIx::FlashFillOrder(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::FlashFillOrder(
                        proto_def::FlashFillOrderIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                LimitOrder2ProgramIx::InitializeOrder(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::InitializeOrder(
                        proto_def::InitializeOrderIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                LimitOrder2ProgramIx::PreFlashFillOrder(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::PreFlashFillOrder(
                        proto_def::PreFlashFillOrderIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                LimitOrder2ProgramIx::UpdateFee(acc, data) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::UpdateFee(
                        proto_def::UpdateFeeIx {
                            accounts: Some(acc.into_proto()),
                            data: Some(data.into_proto()),
                        },
                    )),
                },
                LimitOrder2ProgramIx::WithdrawFee(acc) => proto_def::ProgramIxs {
                    ix_oneof: Some(proto_def::program_ixs::IxOneof::WithdrawFee(
                        proto_def::WithdrawFeeIx {
                            accounts: Some(acc.into_proto()),
                        },
                    )),
                },
            }
        }
    }

    impl ParseProto for InstructionParser {
        type Message = proto_def::ProgramIxs;

        fn output_into_message(value: Self::Output) -> Self::Message { value.into_proto() }
    }
}
