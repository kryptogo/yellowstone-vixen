//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::{BorshDeserialize, BorshSerialize};
use solana_pubkey::Pubkey;

use crate::generated::types::{SwapParameters, SwapResult};

#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct EvtSwap {
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub pool: Pubkey,
    pub trade_direction: u8,
    pub has_referral: bool,
    pub params: SwapParameters,
    pub swap_result: SwapResult,
    pub actual_amount_in: u64,
    pub current_timestamp: u64,
}

impl EvtSwap {
    /// EvtSwap discriminator bytes
    pub const DISCRIMINATOR: [u8; 8] = [0x1b, 0x3c, 0x15, 0xd5, 0x8a, 0xaa, 0xbb, 0x93];

    /// Parse EvtSwap from inner instruction data that starts with self CPI log prefix
    pub fn from_inner_instruction_data(data: &[u8]) -> Option<Self> {
        // Check if data starts with self CPI log prefix: 0xe445a52e51cb9a1d
        let cpi_log_prefix = [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d];
        if !data.starts_with(&cpi_log_prefix) {
            return None;
        }

        // Skip the CPI log prefix (8 bytes)
        let remaining_data = &data[8..];

        // Check if the remaining data starts with EvtSwap discriminator
        if !remaining_data.starts_with(&Self::DISCRIMINATOR) {
            return None;
        }

        // Skip the discriminator (8 bytes) and deserialize the EvtSwap
        Self::try_from_slice(&remaining_data[8..]).ok()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_discriminator_constant() {
        assert_eq!(
            EvtSwap::DISCRIMINATOR,
            [0x1b, 0x3c, 0x15, 0xd5, 0x8a, 0xaa, 0xbb, 0x93]
        );
    }

    #[test]
    fn test_parse_real_inner_instruction_data() {
        // Real inner instruction data from a meteora AMM swap transaction
        let hex_data = "e445a52e51cb9a1d1b3c15d58aaabb9356c3edab34d2380f41e73364b44243a74e8c1df81b839a7d5b18cc64d852a679000000dbc634a303000000000000000000005e2f01000000000014af81c72e11090000000000000000003f000000000000000f000000000000000000000000000000000000000000000000dbc634a3030000fc66d26800000000";

        // Convert hex string to bytes
        let data: Vec<u8> = (0..hex_data.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&hex_data[i..i + 2], 16).unwrap())
            .collect();

        let result = EvtSwap::from_inner_instruction_data(&data);
        assert!(
            result.is_some(),
            "Should successfully parse real inner instruction data"
        );

        let evt_swap = result.unwrap();

        // Verify the parsing worked by checking some fields
        assert_eq!(evt_swap.trade_direction, 0);
        assert_eq!(evt_swap.has_referral, false);
        assert_eq!(evt_swap.actual_amount_in, 3999500000000);
        assert_eq!(evt_swap.swap_result.output_amount, 77662);
    }

    #[test]
    fn test_parse_real_inner_instruction_data_swap2() {
        // Real inner instruction data from a meteora AMM swap transaction (EvtSwap event)
        let hex_data = "e445a52e51cb9a1d1b3c15d58aaabb936d681523b125ad6097af40c1a1d336a71adcecc20afd2984173b40a9be05bac300003fef5d0700000000fb7944000000000005e84800000000003dab2fdda63cd8320000000000000000b8300100000000002e4c000000000000000000000000000000000000000000003fef5d0700000000fa26e76800000000";

        // Convert hex string to bytes
        let data: Vec<u8> = (0..hex_data.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&hex_data[i..i + 2], 16).unwrap())
            .collect();

        let result = EvtSwap::from_inner_instruction_data(&data);
        assert!(
            result.is_some(),
            "Should successfully parse real inner instruction data"
        );

        let evt_swap = result.unwrap();

        // Verify the parsing worked by checking some fields
        assert_eq!(evt_swap.trade_direction, 0);
        assert_eq!(evt_swap.has_referral, false);
        assert_eq!(evt_swap.actual_amount_in, 123596607);
        assert_eq!(evt_swap.swap_result.output_amount, 4777989);
    }

    #[test]
    fn test_cpi_log_prefix_detection() {
        let cpi_log_prefix = [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d];
        let evt_swap_discriminator = [0x1b, 0x3c, 0x15, 0xd5, 0x8a, 0xaa, 0xbb, 0x93];

        // Create test data with CPI log prefix + EvtSwap discriminator + mock data
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&cpi_log_prefix);
        test_data.extend_from_slice(&evt_swap_discriminator);
        test_data.extend_from_slice(&[0u8; 128]); // Mock EvtSwap data

        // Should detect the CPI log prefix
        assert!(test_data.starts_with(&cpi_log_prefix));

        // Should detect the EvtSwap discriminator after CPI prefix
        assert!(test_data[8..].starts_with(&evt_swap_discriminator));
    }

    #[test]
    fn test_invalid_cpi_log_prefix() {
        let invalid_prefix = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        let evt_swap_discriminator = [0x1b, 0x3c, 0x15, 0xd5, 0x8a, 0xaa, 0xbb, 0x93];

        let mut test_data = Vec::new();
        test_data.extend_from_slice(&invalid_prefix);
        test_data.extend_from_slice(&evt_swap_discriminator);
        test_data.extend_from_slice(&[0u8; 128]);

        let result = EvtSwap::from_inner_instruction_data(&test_data);
        assert!(
            result.is_none(),
            "Should not parse with invalid CPI log prefix"
        );
    }
}
