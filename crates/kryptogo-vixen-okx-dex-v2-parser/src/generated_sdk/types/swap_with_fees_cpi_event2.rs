//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::{BorshDeserialize, BorshSerialize};
use solana_pubkey::Pubkey;

#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SwapWithFeesCpiEvent2 {
    pub order_id: u64,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub source_mint: Pubkey,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub destination_mint: Pubkey,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub source_token_account_owner: Pubkey,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub destination_token_account_owner: Pubkey,
    pub amount_in: u64,
    pub source_token_change: u64,
    pub destination_token_change: u64,
    pub commission_direction: bool,
    pub commission_rate: u32,
    pub commission_amount: u64,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub commission_account: Pubkey,
    pub platform_fee_rate: u16,
    pub platform_fee_amount: u64,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub platform_fee_account: Pubkey,
    pub trim_rate: u8,
    pub trim_amount: u64,
    #[cfg_attr(
        feature = "serde",
        serde(with = "serde_with::As::<serde_with::DisplayFromStr>")
    )]
    pub trim_account: Pubkey,
}

impl SwapWithFeesCpiEvent2 {
    /// CPI log prefix for self CPI events (Anchor standard)
    pub const CPI_LOG_PREFIX: [u8; 8] = [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d];
    /// SwapWithFeesCpiEvent2 discriminator bytes (from IDL)
    pub const DISCRIMINATOR: [u8; 8] = [0x0c, 0x86, 0x26, 0x5d, 0xa7, 0x97, 0x2a, 0x45];

    /// Parse from inner instruction data with CPI log prefix
    pub fn from_inner_instruction_data(data: &[u8]) -> Option<Self> {
        if !data.starts_with(&Self::CPI_LOG_PREFIX) {
            return None;
        }

        let remaining_data = &data[8..];

        if !remaining_data.starts_with(&Self::DISCRIMINATOR) {
            return None;
        }

        Self::try_from_slice(&remaining_data[8..]).ok()
    }
}

#[cfg(test)]
mod tests {
    use borsh::BorshSerialize;

    use super::*;

    #[test]
    fn test_discriminator_constant() {
        assert_eq!(SwapWithFeesCpiEvent2::DISCRIMINATOR, [
            0x0c, 0x86, 0x26, 0x5d, 0xa7, 0x97, 0x2a, 0x45
        ]);
    }

    #[test]
    fn test_parse_serialized_event() {
        let mock_event = SwapWithFeesCpiEvent2 {
            order_id: 12345,
            source_mint: Pubkey::new_from_array([1u8; 32]),
            destination_mint: Pubkey::new_from_array([2u8; 32]),
            source_token_account_owner: Pubkey::new_from_array([3u8; 32]),
            destination_token_account_owner: Pubkey::new_from_array([4u8; 32]),
            amount_in: 1000000,
            source_token_change: 1000000,
            destination_token_change: 500000,
            commission_direction: false,
            commission_rate: 100,
            commission_amount: 500,
            commission_account: Pubkey::new_from_array([5u8; 32]),
            platform_fee_rate: 10,
            platform_fee_amount: 100,
            platform_fee_account: Pubkey::new_from_array([6u8; 32]),
            trim_rate: 5,
            trim_amount: 50,
            trim_account: Pubkey::new_from_array([7u8; 32]),
        };

        let mut event_data = Vec::new();
        mock_event
            .serialize(&mut event_data)
            .expect("Failed to serialize");

        let mut data = Vec::new();
        data.extend_from_slice(&SwapWithFeesCpiEvent2::CPI_LOG_PREFIX);
        data.extend_from_slice(&SwapWithFeesCpiEvent2::DISCRIMINATOR);
        data.extend_from_slice(&event_data);

        let result = SwapWithFeesCpiEvent2::from_inner_instruction_data(&data);
        assert!(result.is_some());

        let parsed_event = result.unwrap();
        assert_eq!(parsed_event.order_id, 12345);
        assert_eq!(parsed_event.source_token_change, 1000000);
        assert_eq!(parsed_event.destination_token_change, 500000);
    }

    #[test]
    fn test_parse_real_swap_tob_inner_instruction_data() {
        // Real inner instruction data from OKX DEX V2 SwapTob transaction
        // Transaction: 5u7r6JJbEcacdTUyPicWt12Tf6BtsCkKTY7tsUcVVwRabPsjXBbLf4xaoVeYiP8ahyaQGS18mzU8TbamNqM1him8
        // Swap: 0.1 SOL -> 6255.774767 gork via PumpSwap AMM
        // Wallet: EQ7CzwjgzkZmpQ1RWThBAdjk3VkVLVrzZWU9ZdCPwAUN
        let hex_data = "e445a52e51cb9a1d0c86265da7972a456958030000000000069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f000000000010a32a247f364e154b81aa05a04de4c3271746a874a7dee5a86ae60e5d9ca0557c7134e89f757df9c1b1b589267b9e3aa091638c90b02f8c878d9d36a79654927c7134e89f757df9c1b1b589267b9e3aa091638c90b02f8c878d9d36a7965492700e1f5050000000000e1f505000000002f8cdf740100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064000000000000000057367a00eb91f5ddf46d0944418e20af1642436add27de4567408617c0a92f37";

        let data = hex::decode(hex_data).expect("Failed to decode hex");
        let result = SwapWithFeesCpiEvent2::from_inner_instruction_data(&data);
        assert!(result.is_some(), "SwapWithFeesCpiEvent2 should parse real SwapTob CPI event");

        let event = result.unwrap();
        assert_eq!(event.order_id, 219241);
        // source_mint = SOL (So11111111111111111111111111111111111111112)
        assert_eq!(
            event.source_mint.to_string(),
            "So11111111111111111111111111111111111111112"
        );
        // destination_mint = gork
        assert_eq!(
            event.destination_mint.to_string(),
            "gorkrgj6k4K449Qa4eF1NaWC5cNLQtMsVEikhpGn7fC"
        );
        // wallet = EQ7CzwjgzkZmpQ1RWThBAdjk3VkVLVrzZWU9ZdCPwAUN
        assert_eq!(
            event.source_token_account_owner.to_string(),
            "EQ7CzwjgzkZmpQ1RWThBAdjk3VkVLVrzZWU9ZdCPwAUN"
        );
        assert_eq!(
            event.destination_token_account_owner.to_string(),
            "EQ7CzwjgzkZmpQ1RWThBAdjk3VkVLVrzZWU9ZdCPwAUN"
        );
        // 0.1 SOL = 100_000_000 lamports
        assert_eq!(event.amount_in, 100_000_000);
        assert_eq!(event.source_token_change, 100_000_000);
        // 6255.774767 gork (6 decimals) = 6_255_774_767
        assert_eq!(event.destination_token_change, 6_255_774_767);
    }
}
