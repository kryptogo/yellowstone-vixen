//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::{BorshDeserialize, BorshSerialize};

use crate::generated::types::{RemainingAccountsInfo, Side};

#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum Swap {
    Saber,
    SaberAddDecimalsDeposit,
    SaberAddDecimalsWithdraw,
    TokenSwap,
    Sencha,
    Step,
    Cropper,
    Raydium,
    Crema {
        a_to_b: bool,
    },
    Lifinity,
    Mercurial,
    Cykura,
    Serum {
        side: Side,
    },
    MarinadeDeposit,
    MarinadeUnstake,
    Aldrin {
        side: Side,
    },
    AldrinV2 {
        side: Side,
    },
    Whirlpool {
        a_to_b: bool,
    },
    Invariant {
        x_to_y: bool,
    },
    Meteora,
    GooseFX,
    DeltaFi {
        stable: bool,
    },
    Balansol,
    MarcoPolo {
        x_to_y: bool,
    },
    Dradex {
        side: Side,
    },
    LifinityV2,
    RaydiumClmm,
    Openbook {
        side: Side,
    },
    Phoenix {
        side: Side,
    },
    Symmetry {
        from_token_id: u64,
        to_token_id: u64,
    },
    TokenSwapV2,
    HeliumTreasuryManagementRedeemV0,
    StakeDexStakeWrappedSol,
    StakeDexSwapViaStake {
        bridge_stake_seed: u32,
    },
    GooseFXV2,
    Perps,
    PerpsAddLiquidity,
    PerpsRemoveLiquidity,
    MeteoraDlmm,
    OpenBookV2 {
        side: Side,
    },
    RaydiumClmmV2,
    StakeDexPrefundWithdrawStakeAndDepositStake {
        bridge_stake_seed: u32,
    },
    Clone {
        pool_index: u8,
        quantity_is_input: bool,
        quantity_is_collateral: bool,
    },
    SanctumS {
        src_lst_value_calc_accs: u8,
        dst_lst_value_calc_accs: u8,
        src_lst_index: u32,
        dst_lst_index: u32,
    },
    SanctumSAddLiquidity {
        lst_value_calc_accs: u8,
        lst_index: u32,
    },
    SanctumSRemoveLiquidity {
        lst_value_calc_accs: u8,
        lst_index: u32,
    },
    RaydiumCP,
    WhirlpoolSwapV2 {
        a_to_b: bool,
        remaining_accounts_info: Option<RemainingAccountsInfo>,
    },
    OneIntro,
    PumpWrappedBuy,
    PumpWrappedSell,
    PerpsV2,
    PerpsV2AddLiquidity,
    PerpsV2RemoveLiquidity,
    MoonshotWrappedBuy,
    MoonshotWrappedSell,
    StabbleStableSwap,
    StabbleWeightedSwap,
    Obric {
        x_to_y: bool,
    },
    FoxBuyFromEstimatedCost,
    FoxClaimPartial {
        is_y: bool,
    },
    SolFi {
        is_quote_to_base: bool,
    },
    SolayerDelegateNoInit,
    SolayerUndelegateNoInit,
    TokenMill {
        side: Side,
    },
    DaosFunBuy,
    DaosFunSell,
    ZeroFi,
    StakeDexWithdrawWrappedSol,
    VirtualsBuy,
    VirtualsSell,
    Perena {
        in_index: u8,
        out_index: u8,
    },
    PumpSwapBuy,
    PumpSwapSell,
    Gamma,
    MeteoraDlmmSwapV2 {
        remaining_accounts_info: RemainingAccountsInfo,
    },
    Woofi,
    MeteoraDammV2,
    MeteoraDynamicBondingCurveSwap,
    StabbleStableSwapV2,
    StabbleWeightedSwapV2,
    RaydiumLaunchlabBuy {
        share_fee_rate: u64,
    },
    RaydiumLaunchlabSell {
        share_fee_rate: u64,
    },
    BoopdotfunWrappedBuy,
    BoopdotfunWrappedSell,
    Plasma {
        side: Side,
    },
    GoonFi {
        is_bid: bool,
        blacklist_bump: u8,
    },
    HumidiFi {
        swap_id: u64,
        is_base_to_quote: bool,
    },
    MeteoraDynamicBondingCurveSwapWithRemainingAccounts,
    TesseraV {
        side: Side,
    },
    PumpWrappedBuyV2,
    PumpWrappedSellV2,
    PumpSwapBuyV2,
    PumpSwapSellV2,
    Heaven {
        a_to_b: bool,
    },
    SolFiV2 {
        is_quote_to_base: bool,
    },
    Aquifer,
    PumpWrappedBuyV3,
    PumpWrappedSellV3,
    PumpSwapBuyV3,
    PumpSwapSellV3,
    JupiterLendDeposit,
    JupiterLendRedeem,
    DefiTuna {
        a_to_b: bool,
        remaining_accounts_info: Option<RemainingAccountsInfo>,
    },
    AlphaQ {
        a_to_b: bool,
    },
    RaydiumV2,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_shared_accounts_route_with_unknown_swap() {
        // Hex data from the user - includes 8-byte instruction discriminator
        // This data contains swap discriminator 108 (MeteoraDammV2WithRemainingAccounts)
        // which doesn't exist in the current SDK, testing forward compatibility
        let hex = "c1209b3341d69c8101030000006c64000157045dbfef6229530e0064010226640203904d414c0300000048392e1300000000640000";
        let data = hex::decode(hex).expect("Failed to decode hex");

        // Skip the 8-byte instruction discriminator to get instruction args
        let args_data = &data[8..];

        // Try to deserialize as SharedAccountsRouteInstructionArgs
        use crate::generated_sdk::instructions::SharedAccountsRouteInstructionArgs;
        match SharedAccountsRouteInstructionArgs::try_from_slice(args_data) {
            Ok(ix_data) => {
                println!("\n=== Successfully deserialized with forward compatibility! ===");
                println!("ID: {}", ix_data.id);
                println!(
                    "Route plan steps: {} (empty due to unknown swap types)",
                    ix_data.route_plan.len()
                );

                println!("\n=== Transaction Details (parsed from end) ===");
                println!("In amount: {}", ix_data.in_amount);
                println!("Quoted out amount: {}", ix_data.quoted_out_amount);
                println!("Slippage BPS: {}", ix_data.slippage_bps);
                println!("Platform fee BPS: {}", ix_data.platform_fee_bps);

                // Verify we have the expected data from the fixed fields
                assert_eq!(ix_data.id, 1);
                assert_eq!(ix_data.in_amount, 14164250000);
                assert_eq!(ix_data.quoted_out_amount, 321796424);
                assert_eq!(ix_data.slippage_bps, 100);
                assert_eq!(ix_data.platform_fee_bps, 0);

                // Route plan should be empty because it contains unknown swap type
                assert_eq!(
                    ix_data.route_plan.len(),
                    0,
                    "Route plan should be empty when unknown swaps are encountered"
                );

                println!(
                    "\n✓ Forward compatibility working! We can still parse amounts and fees even \
                     with unknown swap types."
                );
            },
            Err(e) => {
                panic!("Failed to deserialize: {:?}", e);
            },
        }
    }

    #[test]
    fn test_deserialize_shared_accounts_route_with_unknown_swap_case2() {
        // Second test case with different unknown swap types
        let hex = "c1209b3341d69c81020400000068016400015900640102265802046c0c0204005ed0b200000000305e167767010100000000";
        let data = hex::decode(hex).expect("Failed to decode hex");

        // Skip the 8-byte instruction discriminator
        let args_data = &data[8..];

        // Deserialize
        use crate::generated_sdk::instructions::SharedAccountsRouteInstructionArgs;
        match SharedAccountsRouteInstructionArgs::try_from_slice(args_data) {
            Ok(ix_data) => {
                println!("\n=== Case 2: Successfully deserialized with forward compatibility! ===");
                println!("ID: {}", ix_data.id);
                println!(
                    "Route plan steps: {} (empty due to unknown swap types)",
                    ix_data.route_plan.len()
                );

                println!("\n=== Transaction Details (parsed from end) ===");
                println!("In amount: {}", ix_data.in_amount);
                println!("Quoted out amount: {}", ix_data.quoted_out_amount);
                println!("Slippage BPS: {}", ix_data.slippage_bps);
                println!("Platform fee BPS: {}", ix_data.platform_fee_bps);

                // Verify the fixed fields
                assert_eq!(ix_data.id, 2);
                assert_eq!(ix_data.in_amount, 3000000000);
                assert_eq!(ix_data.quoted_out_amount, 283018867924528);
                assert_eq!(ix_data.slippage_bps, 0);
                assert_eq!(ix_data.platform_fee_bps, 0);

                // Route plan should be empty due to unknown swap types
                assert_eq!(
                    ix_data.route_plan.len(),
                    0,
                    "Route plan should be empty when unknown swaps are encountered"
                );

                println!("\n✓ Forward compatibility confirmed for case 2!");
            },
            Err(e) => {
                panic!("Failed to deserialize case 2: {:?}", e);
            },
        }
    }
}
