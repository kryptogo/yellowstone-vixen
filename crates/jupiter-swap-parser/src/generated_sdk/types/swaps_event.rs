//! This code was AUTOGENERATED using the codama library.
//! Please DO NOT EDIT THIS FILE, instead use visitors
//! to add features, then rerun codama to update it.
//!
//! <https://github.com/codama-idl/codama>
//!

use borsh::{BorshDeserialize, BorshSerialize};

use crate::generated::types::SwapEventV2;

#[derive(BorshSerialize, BorshDeserialize, Clone, Debug, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SwapsEvent {
    pub swap_events: Vec<SwapEventV2>,
}

impl SwapsEvent {
    /// SwapsEvent discriminator bytes
    pub const DISCRIMINATOR: [u8; 8] = [0x98, 0x2f, 0x4e, 0xeb, 0xc0, 0x60, 0x6e, 0x6a];

    /// Parse SwapsEvent from inner instruction data that starts with self CPI log prefix
    pub fn from_inner_instruction_data(data: &[u8]) -> Option<Self> {
        // Check if data starts with self CPI log prefix: 0xe445a52e51cb9a1d
        let cpi_log_prefix = [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d];
        if !data.starts_with(&cpi_log_prefix) {
            return None;
        }

        // Skip the CPI log prefix (8 bytes)
        let remaining_data = &data[8..];

        // Check if the remaining data starts with SwapsEvent discriminator
        if !remaining_data.starts_with(&Self::DISCRIMINATOR) {
            return None;
        }

        // Skip the discriminator (8 bytes) and deserialize the SwapsEvent
        Self::try_from_slice(&remaining_data[8..]).ok()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_discriminator_constant() {
        assert_eq!(SwapsEvent::DISCRIMINATOR, [
            0x98, 0x2f, 0x4e, 0xeb, 0xc0, 0x60, 0x6e, 0x6a
        ]);
    }

    #[test]
    fn test_parse_real_inner_instruction_data() {
        // Real inner instruction data from a Jupiter V2 swap transaction
        // This is the original data provided by the user
        let hex_data = "e445a52e51cb9a1d982f4eebc0606e6a050000001076469c1041d9e9b39fc2ede11333973b3e95732a4439207193a61cc4108d43c1a4100000000000c6fa7af3bedbad3a3d65f36aabc97431b1bbe4c2d2f6e0e47ca60203452f5d6193e06100000000001076469c1041d9e9b39fc2ede11333973b3e95732a4439207193a61cc4108d432d728f0100000000069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f00000000001cb2af22700000000069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f00000000001a696950b00000000c6fa7af3bedbad3a3d65f36aabc97431b1bbe4c2d2f6e0e47ca60203452f5d61221fa90200000000069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f0000000000125945c1c00000000c6fa7af3bedbad3a3d65f36aabc97431b1bbe4c2d2f6e0e47ca60203452f5d61fcfd830600000000c6fa7af3bedbad3a3d65f36aabc97431b1bbe4c2d2f6e0e47ca60203452f5d61b1fd8e090000000066e5188a1308a1db90b6d31f3fbdca8c3df2678c8112dfdd3d192c5a3cc457a87c6d360000000000";

        // Convert hex string to bytes
        let data = hex::decode(hex_data).unwrap();

        let result = SwapsEvent::from_inner_instruction_data(&data);
        assert!(
            result.is_some(),
            "Should successfully parse real inner instruction data"
        );

        let swaps_event = result.unwrap();

        // Verify we have 5 swap events
        assert_eq!(swaps_event.swap_events.len(), 5);

        // Assert the parsed data matches the expected values
        // Event 0: 27G8MtK7VtTcCHkpASjSDdkWWYfoqT6ggEuKidVJidD4 -> EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
        let event0 = &swaps_event.swap_events[0];
        assert_eq!(
            event0.input_mint.to_string(),
            "27G8MtK7VtTcCHkpASjSDdkWWYfoqT6ggEuKidVJidD4"
        );
        assert_eq!(event0.input_amount, 1090753);
        assert_eq!(
            event0.output_mint.to_string(),
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        );
        assert_eq!(event0.output_amount, 6414483);

        // Event 1: 27G8MtK7VtTcCHkpASjSDdkWWYfoqT6ggEuKidVJidD4 -> So11111111111111111111111111111111111111112
        let event1 = &swaps_event.swap_events[1];
        assert_eq!(
            event1.input_mint.to_string(),
            "27G8MtK7VtTcCHkpASjSDdkWWYfoqT6ggEuKidVJidD4"
        );
        assert_eq!(event1.input_amount, 26178093);
        assert_eq!(
            event1.output_mint.to_string(),
            "So11111111111111111111111111111111111111112"
        );
        assert_eq!(event1.output_amount, 670182091);

        // Event 2: So11111111111111111111111111111111111111112 -> EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
        let event2 = &swaps_event.swap_events[2];
        assert_eq!(
            event2.input_mint.to_string(),
            "So11111111111111111111111111111111111111112"
        );
        assert_eq!(event2.input_amount, 194352806);
        assert_eq!(
            event2.output_mint.to_string(),
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        );
        assert_eq!(event2.output_amount, 44637986);

        // Event 3: So11111111111111111111111111111111111111112 -> EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
        let event3 = &swaps_event.swap_events[3];
        assert_eq!(
            event3.input_mint.to_string(),
            "So11111111111111111111111111111111111111112"
        );
        assert_eq!(event3.input_amount, 475829285);
        assert_eq!(
            event3.output_mint.to_string(),
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        );
        assert_eq!(event3.output_amount, 109313532);

        // Event 4: EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v -> 7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs
        let event4 = &swaps_event.swap_events[4];
        assert_eq!(
            event4.input_mint.to_string(),
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
        );
        assert_eq!(event4.input_amount, 160366001);
        assert_eq!(
            event4.output_mint.to_string(),
            "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"
        );
        assert_eq!(event4.output_amount, 3566972);
    }

    #[test]
    fn test_cpi_log_prefix_detection() {
        let cpi_log_prefix = [0xe4, 0x45, 0xa5, 0x2e, 0x51, 0xcb, 0x9a, 0x1d];
        let swaps_event_discriminator = [0x98, 0x2f, 0x4e, 0xeb, 0xc0, 0x60, 0x6e, 0x6a];

        // Create test data with CPI log prefix + SwapsEvent discriminator + mock data
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&cpi_log_prefix);
        test_data.extend_from_slice(&swaps_event_discriminator);
        // Add vec length (0 swap events)
        test_data.extend_from_slice(&[0u8; 4]);

        // Should detect the CPI log prefix
        assert!(test_data.starts_with(&cpi_log_prefix));

        // Should detect the SwapsEvent discriminator after CPI prefix
        assert!(test_data[8..].starts_with(&swaps_event_discriminator));
    }

    #[test]
    fn test_invalid_cpi_log_prefix() {
        let invalid_prefix = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        let swaps_event_discriminator = [0x98, 0x2f, 0x4e, 0xeb, 0xc0, 0x60, 0x6e, 0x6a];

        let mut test_data = Vec::new();
        test_data.extend_from_slice(&invalid_prefix);
        test_data.extend_from_slice(&swaps_event_discriminator);
        test_data.extend_from_slice(&[0u8; 128]);

        let result = SwapsEvent::from_inner_instruction_data(&test_data);
        assert!(
            result.is_none(),
            "Should not parse with invalid CPI log prefix"
        );
    }
}
